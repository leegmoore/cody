<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cody Agent Harness</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        tan: {
                            50: "#fdf8f3",
                            100: "#f5f0ea",
                            200: "#eadfce",
                            300: "#d8c3ae",
                            400: "#c8a789",
                            500: "#b78969",
                            600: "#9f6d4f"
                        },
                        brown: {
                            50: "#f8f1ea",
                            100: "#eddecf",
                            600: "#7a4b2f",
                            700: "#613623",
                            800: "#4a2717",
                            900: "#2f180e"
                        }
                    }
                }
            }
        };
    </script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .message-content {
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        
        .tool-card {
            transition: all 0.2s ease;
        }
        
        .tool-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .composer-textarea {
            resize: none;
            transition: height 0.2s ease;
        }
        
        .sidebar {
            transition: margin-left 0.3s ease, margin-right 0.3s ease;
        }
        
        .file-tree-item {
            cursor: pointer;
            user-select: none;
        }
        
        .file-tree-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .nav-item {
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .nav-item:hover {
            background-color: rgba(234, 88, 12, 0.1);
        }
        
        .nav-item.active {
            background-color: rgba(234, 88, 12, 0.15);
            border-left: 3px solid #ea580c;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f5f0ea;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #c19a7d;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #a97c5d;
        }
        
        /* Line clamp utility */
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Modal backdrop */
        .modal-backdrop {
            background-color: rgba(67, 48, 43, 0.75);
            backdrop-filter: blur(4px);
        }
        
        /* Inline tool call cards */
        .tool-call-stack-wrapper {
            position: relative;
            width: min(28rem, 100%);
            padding-bottom: 0.75rem;
        }

        .tool-call-cards {
            position: relative;
            width: min(26rem, 100%);
            min-height: var(--tool-card-stack-height, 6rem);
            padding-top: 0.25rem;
            --tool-stack-x: 1.5rem;
            --tool-stack-y: 1.75rem;
            overflow: visible;
        }

        .tool-call-card {
            pointer-events: auto;
            backdrop-filter: blur(3px);
            background: linear-gradient(145deg, #fff8f3, #ffe4d1);
            border: 2px solid rgba(234, 88, 12, 0.18);
            box-shadow: 0 12px 30px rgba(96, 54, 23, 0.25);
            transition: transform 0.18s ease, box-shadow 0.18s ease;
        }
        
        .tool-call-card:hover {
            transform: translate3d(
                calc(var(--stack-index, 0) * var(--tool-stack-x) - 2px),
                calc(var(--stack-index, 0) * var(--tool-stack-y) - 3px),
                0
            );
            box-shadow: 0 18px 36px rgba(96, 54, 23, 0.30);
        }

        .tool-call-card-layered {
            position: absolute;
            width: calc(100% - (var(--stack-index, 0) * 0.15rem));
            left: 0;
            top: 0;
            transform: translate3d(
                calc(var(--stack-index, 0) * var(--tool-stack-x)),
                calc(var(--stack-index, 0) * var(--tool-stack-y)),
                0
            );
        }

        .tool-card-status {
            font-variant-numeric: tabular-nums;
        }

        .tool-status-progress {
            background: linear-gradient(90deg, rgba(245, 158, 11, 0.25), rgba(234, 88, 12, 0.9), rgba(245, 158, 11, 0.25));
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: progressShimmer 1.25s linear infinite;
        }

        @keyframes progressShimmer {
            0% {
                background-position: 0% 50%;
            }
            100% {
                background-position: 200% 50%;
            }
        }

        .tool-modal-pre {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.8rem;
            background-color: #fdf8f3;
            border: 1px solid #e6d5c2;
            border-radius: 0.5rem;
            padding: 0.75rem;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 30vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-tan-100 h-screen overflow-hidden">
    <!-- Main Container -->
    <div class="flex h-screen">
        <!-- Left Sidebar - File Tree -->
        <div id="leftSidebar" class="sidebar w-64 bg-brown-900 text-tan-100 flex flex-col shadow-lg">
            <!-- Header -->
            <div class="p-4 border-b border-brown-800 flex items-center justify-between">
                <h2 class="font-semibold text-lg flex items-center">
                    <svg class="w-5 h-5 mr-2 text-orange-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
                    </svg>
                    Project
                </h2>
                <button onclick="toggleLeftSidebar()" class="text-tan-300 hover:text-tan-100">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7"></path>
                    </svg>
                </button>
            </div>
            
            <!-- File Tree -->
            <div class="flex-1 overflow-y-auto p-2">
                <div class="space-y-1">
                    <!-- Mock file structure -->
                    <div class="file-tree-item px-2 py-1 rounded text-sm flex items-center">
                        <svg class="w-4 h-4 mr-2 text-orange-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
                        </svg>
                        src
                    </div>
                    <div class="ml-4 space-y-1">
                        <div class="file-tree-item px-2 py-1 rounded text-sm flex items-center text-tan-300">
                            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            server.ts
                        </div>
                        <div class="file-tree-item px-2 py-1 rounded text-sm flex items-center text-tan-300">
                            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            agent.ts
                        </div>
                        <div class="file-tree-item px-2 py-1 rounded text-sm flex items-center text-tan-300">
                            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            tools.ts
                        </div>
                    </div>
                    
                    <div class="file-tree-item px-2 py-1 rounded text-sm flex items-center">
                        <svg class="w-4 h-4 mr-2 text-orange-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
                        </svg>
                        tests
                    </div>
                    <div class="ml-4 space-y-1">
                        <div class="file-tree-item px-2 py-1 rounded text-sm flex items-center text-tan-300">
                            <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            agent.test.ts
                        </div>
                    </div>
                    
                    <div class="file-tree-item px-2 py-1 rounded text-sm flex items-center text-tan-300">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        package.json
                    </div>
                    <div class="file-tree-item px-2 py-1 rounded text-sm flex items-center text-tan-300">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        README.md
                    </div>
                    <div class="file-tree-item px-2 py-1 rounded text-sm flex items-center text-tan-300">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        tsconfig.json
                    </div>
                </div>
            </div>
        </div>

        <!-- Toggle button when sidebar is collapsed -->
        <button id="leftSidebarToggle" class="hidden fixed left-0 top-1/2 transform -translate-y-1/2 bg-brown-900 text-tan-100 p-2 rounded-r-lg shadow-lg z-10" onclick="toggleLeftSidebar()">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"></path>
            </svg>
        </button>

        <!-- Main Content Area -->
        <div class="flex-1 flex flex-col bg-tan-50">
            <!-- Header -->
            <div class="bg-brown-800 text-tan-100 px-6 py-3 shadow-md flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <div class="w-8 h-8 bg-orange-600 rounded-lg flex items-center justify-center font-bold text-white">
                        C
                    </div>
                    <div>
                        <h1 class="font-semibold text-lg">Cody Agent</h1>
                        <p class="text-xs text-tan-300" id="conversationTitle">Ready to help</p>
                    </div>
                </div>
                <div class="flex items-center space-x-2">
                    <span class="text-xs text-tan-300" id="statusIndicator">
                        <span class="inline-block w-2 h-2 bg-green-500 rounded-full mr-1"></span>
                        Connected
                    </span>
                </div>
            </div>

            <!-- Chat History -->
            <div id="chatHistory" class="flex-1 overflow-y-auto px-6 py-4 space-y-6">
                <div class="flex items-center justify-center h-full text-tan-600">
                    <div class="text-center">
                        <p class="text-lg">Start a conversation</p>
                        <p class="text-sm mt-2">Type a message below to begin</p>
                    </div>
                </div>
            </div>

            <!-- Composer -->
            <div class="bg-white border-t border-tan-300 px-6 py-4">
                <div class="max-w-4xl mx-auto">
                    <div class="relative">
                        <textarea 
                            id="messageInput" 
                            class="composer-textarea w-full px-4 py-3 pr-12 border-2 border-tan-400 rounded-lg focus:outline-none focus:border-orange-500 bg-tan-50 text-brown-900 placeholder-tan-500"
                            placeholder="Send a message to Cody..."
                            rows="3"
                            style="max-height: 168px;"
                        ></textarea>
                        <button 
                            id="sendButton"
                            onclick="sendMessage()"
                            class="absolute right-2 bottom-2 bg-orange-600 hover:bg-orange-700 text-white p-2 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                        >
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="flex items-center justify-between mt-2 text-xs text-tan-600">
                        <span>Press Enter to send, Shift+Enter for new line</span>
                        <span id="charCount">0 / 4000</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Sidebar - Conversations List -->
        <div id="rightSidebar" class="sidebar w-64 bg-brown-50 border-l border-tan-300 flex flex-col shadow-lg">
            <!-- Header -->
            <div class="p-4 border-b border-tan-300 flex items-center justify-between bg-brown-100">
                <h2 class="font-semibold text-brown-900 flex items-center">
                    <svg class="w-5 h-5 mr-2 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z"></path>
                    </svg>
                    Conversations
                </h2>
                <button onclick="toggleRightSidebar()" class="text-brown-700 hover:text-brown-900">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"></path>
                    </svg>
                </button>
            </div>
            
            <!-- New Conversation Button -->
            <div class="p-3 border-b border-tan-300">
                <button onclick="createNewConversation()" class="w-full bg-orange-600 hover:bg-orange-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center justify-center text-sm font-medium">
                    <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                    </svg>
                    New Chat
                </button>
            </div>
            
            <!-- Conversations List -->
            <div id="conversationsList" class="flex-1 overflow-y-auto">
                <div class="flex items-center justify-center h-full text-tan-600">
                    <div class="text-center">
                        <p class="text-sm">Loading conversations...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Toggle button when right sidebar is collapsed -->
        <button id="rightSidebarToggle" class="hidden fixed right-0 top-1/2 transform -translate-y-1/2 bg-brown-100 text-brown-900 p-2 rounded-l-lg shadow-lg z-10" onclick="toggleRightSidebar()">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19l-7-7 7-7m8 14l-7-7 7-7"></path>
            </svg>
        </button>
    </div>

    <!-- Tool Call Detail Modal -->
    <div id="toolCallModal" class="hidden fixed inset-0 z-40 items-center justify-center">
        <div class="modal-backdrop absolute inset-0" onclick="closeToolCallModal()"></div>
        <div class="relative bg-white rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col overflow-hidden">
            <!-- Header -->
            <div class="flex items-center justify-between px-6 py-4 bg-brown-800 border-b border-brown-700">
                <h3 id="modalToolName" class="text-sm font-mono font-medium text-tan-50 break-all line-clamp-2 pr-4">Tool call</h3>
                <button class="text-tan-400 hover:text-white transition-colors" onclick="closeToolCallModal()" aria-label="Close tool details">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            
            <!-- Content -->
            <div class="flex-1 overflow-y-auto bg-white p-0">
                <div class="p-6 space-y-6">
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <h4 class="text-xs font-bold uppercase tracking-wider text-gray-500">Tool Call</h4>
                        </div>
                        <div class="bg-gray-50 rounded-md border border-gray-200 overflow-hidden">
                            <pre id="modalToolArgs" class="p-4 text-sm font-mono text-gray-800 whitespace-pre-wrap overflow-x-auto"></pre>
                        </div>
                    </div>
                    
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <h4 class="text-xs font-bold uppercase tracking-wider text-gray-500">Tool Call Response</h4>
                        </div>
                        <div class="bg-gray-50 rounded-md border border-gray-200 overflow-hidden">
                            <pre id="modalToolOutput" class="p-4 text-sm font-mono text-gray-800 whitespace-pre-wrap overflow-x-auto"></pre>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Footer -->
            <div class="px-6 py-4 bg-tan-50 border-t border-tan-200 flex justify-end">
                <button onclick="closeToolCallModal()" class="bg-orange-600 hover:bg-orange-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Tool Detail Modal -->
    <script>
        // State management
        let currentConversationId = null;
        let eventSource = null;
        let messageHistory = [];
        let currentTurnId = null;
        let toolCalls = [];
        let toolCallModalCallId = null;
        const toolCallTimelines = new Map();
        let fallbackTurnCounter = 0;
        const API_BASE = 'http://localhost:4010/api/v1';
        const TOOL_CARD_STACK_OFFSETS = { x: 8, y: 23 };
        const TOOL_CARD_BASE_HEIGHT = 80;
        let toolCallSequence = 0;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            setupEventListeners();
        });

        function resetToolCallState(options = {}) {
            const { flushHistory = false } = options;
            if (flushHistory) {
                toolCalls = [];
                toolCallTimelines.forEach(({ element }) => {
                    if (element?.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                });
                toolCallTimelines.clear();
                toolCallSequence = 0;
            }
            toolCallModalCallId = null;
            closeToolCallModal(true);
        }

        function normalizeTurnId(value) {
            if (value === undefined || value === null || value === '') {
                return null;
            }
            return String(value);
        }

        function resolveTurnId(preferred) {
            const normalized = normalizeTurnId(preferred);
            if (normalized) {
                return normalized;
            }
            fallbackTurnCounter += 1;
            return `turnless-${fallbackTurnCounter}`;
        }

        function ensureToolTimeline(turnId) {
            if (!turnId) {
                return null;
            }
            let timeline = toolCallTimelines.get(turnId);
            if (timeline && document.body.contains(timeline.element)) {
                return timeline;
            }

            const chatHistory = document.getElementById('chatHistory');
            if (!chatHistory) return null;

            const wrapper = document.createElement('div');
            wrapper.className = 'flex justify-start';
            wrapper.dataset.toolTimelineId = turnId;
            wrapper.innerHTML = `
                <div class="tool-call-stack-wrapper">
                    <div class="tool-call-cards"></div>
                </div>
            `;

            chatHistory.appendChild(wrapper);
            scrollToBottom();

            const cardsContainer = wrapper.querySelector('.tool-call-cards');
            timeline = { element: wrapper, cardsContainer };
            toolCallTimelines.set(turnId, timeline);
            return timeline;
        }

        function truncateText(value, limit = 120) {
            if (!value || value.length <= limit) {
                return value || '';
            }
            return value.slice(0, limit - 3) + '...';
        }

        function formatArgValueForSignature(value) {
            if (value === null) return 'null';
            if (value === undefined) return 'undefined';
            if (typeof value === 'string') {
                const safe = value.replace(/"/g, '\\"');
                return `"${truncateText(safe, 60)}"`;
            }
            if (typeof value === 'number' || typeof value === 'boolean') {
                return String(value);
            }
            if (Array.isArray(value)) {
                return `[${value.slice(0, 3).map(formatArgValueForSignature).join(', ')}${value.length > 3 ? ', …' : ''}]`;
            }
            if (typeof value === 'object') {
                try {
                    return truncateText(JSON.stringify(value), 60);
                } catch {
                    return '[Object]';
                }
            }
            return String(value);
        }

        function formatToolCallSignature(call) {
            const toolLabel = call.toolName || call.type || 'Tool';
            const args = call.arguments;
            if (args === undefined || args === null) {
                return `${toolLabel}()`;
            }
            if (typeof args === 'string') {
                return `${toolLabel}(${truncateText(args, 140)})`;
            }
            if (Array.isArray(args)) {
                return `${toolLabel}([${args.slice(0, 3).map(formatArgValueForSignature).join(', ')}${args.length > 3 ? ', …' : ''}])`;
            }
            if (typeof args === 'object') {
                const entries = Object.entries(args).map(([key, value]) => `${key}: ${formatArgValueForSignature(value)}`);
                return `${toolLabel}({ ${truncateText(entries.join(', '), 140)} })`;
            }
            return `${toolLabel}(${String(args)})`;
        }

        function getToolStatusMeta(status) {
            if (status === 'in_progress') {
                return {
                    className: 'tool-status-progress',
                    text: 'In progress...',
                    icon: `
                        <svg class="w-4 h-4 text-orange-500 animate-spin" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"></path>
                        </svg>
                    `
                };
            }
            if (status === 'error') {
                return {
                    className: 'text-red-600',
                    text: 'Failed',
                    icon: `
                        <svg class="w-4 h-4 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    `
                };
            }
            return {
                className: 'text-green-700',
                text: 'Completed',
                icon: `
                    <svg class="w-4 h-4 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                `
            };
        }

        function updateToolCallStack(turnId) {
            const normalizedTurnId = normalizeTurnId(turnId);
            if (!normalizedTurnId) {
                return;
            }

            const callsForTurn = toolCalls
                .filter((call) => call.turnId === normalizedTurnId)
                // Sort oldest first (sequence 1) to newest (sequence N)
                // Sequence 1: index 0 -> stack-index 0 (top, left, back)
                // Sequence N: index N -> stack-index N (bottom, right, front)
                .sort((a, b) => {
                    return (a.sequence || 0) - (b.sequence || 0);
                });

            if (!callsForTurn.length) {
                return;
            }

            const timeline = ensureToolTimeline(normalizedTurnId);
            if (!timeline || !timeline.cardsContainer) {
                return;
            }

            timeline.cardsContainer.innerHTML = '';
            timeline.cardsContainer.style.setProperty('--tool-stack-x', `${TOOL_CARD_STACK_OFFSETS.x}px`);
            timeline.cardsContainer.style.setProperty('--tool-stack-y', `${TOOL_CARD_STACK_OFFSETS.y}px`);

            callsForTurn.forEach((call, index) => {
                const card = document.createElement('div');
                const signature = formatToolCallSignature(call);
                const statusMeta = getToolStatusMeta(call.status);

                card.className = 'tool-call-card tool-call-card-layered rounded-lg px-3 pt-[5px] pb-2 cursor-pointer';
                card.style.setProperty('--stack-index', index);
                card.style.zIndex = `${index + 1}`;
                card.dataset.callId = call.callId || '';
                card.innerHTML = `
                    <div class="w-full">
                        <p class="text-xs font-mono text-brown-900 truncate w-full" title="${escapeHtml(signature)}">${escapeHtml(signature)}</p>
                        <div class="tool-card-status mt-1 flex items-center gap-2 text-[10px] font-semibold ${statusMeta.className}">
                            ${statusMeta.icon}
                            <span>${statusMeta.text}</span>
                        </div>
                    </div>
                `;

                card.onclick = () => openToolCallModal(call.callId);
                timeline.cardsContainer.appendChild(card);
            });

            const referenceCard = timeline.cardsContainer.querySelector('.tool-call-card-layered');
            if (referenceCard) {
                const rect = referenceCard.getBoundingClientRect();
                const baseHeight = rect?.height || TOOL_CARD_BASE_HEIGHT;
                const stackHeight = Math.max(
                    baseHeight + (TOOL_CARD_STACK_OFFSETS.y * (callsForTurn.length - 1)),
                    TOOL_CARD_BASE_HEIGHT
                );
                timeline.cardsContainer.style.setProperty('--tool-card-stack-height', `${stackHeight + 24}px`);
            } else {
                timeline.cardsContainer.style.removeProperty('--tool-card-stack-height');
            }

            scrollToBottom();
        }

        function formatToolCallJson(value) {
            if (value === undefined || value === null) {
                return '—';
            }
            if (typeof value === 'string') {
                return value;
            }
            try {
                return JSON.stringify(value, null, 2);
            } catch {
                return String(value);
            }
        }

        function renderToolCallModalContent(call) {
            if (!call) return;
            
            // Title: Tool call command signature
            const signature = formatToolCallSignature(call);
            document.getElementById('modalToolName').textContent = signature;
            
            // Helper for smart JSON formatting
            const formatJsonContent = (value) => {
                if (value === undefined || value === null) return 'No content';

                // Recursive function to unwrap nested JSON strings
                const unwrap = (item) => {
                    if (typeof item === 'string') {
                        const trimmed = item.trim();
                        if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
                            try {
                                return unwrap(JSON.parse(item));
                            } catch {
                                return item;
                            }
                        }
                        return item;
                    }
                    
                    if (Array.isArray(item)) {
                        return item.map(unwrap);
                    }
                    
                    if (item !== null && typeof item === 'object') {
                        const copy = {};
                        for (const key in item) {
                            copy[key] = unwrap(item[key]);
                        }
                        return copy;
                    }
                    
                    return item;
                };

                try {
                    const unwrapped = unwrap(value);
                    if (typeof unwrapped === 'object') {
                        let str = JSON.stringify(unwrapped, null, 2);
                        // Replace escaped newlines and tabs with actual characters for readability
                        // This makes the JSON "invalid" technically, but much better for human reading
                        str = str.replace(/\\n/g, '\n').replace(/\\t/g, '\t');
                        return str;
                    }
                    return String(unwrapped);
                } catch (e) {
                    return String(value);
                }
            };

            // Helper for highlighting
            const highlightJson = (content) => {
                try {
                    if (window.hljs) {
                        return window.hljs.highlight(content, { language: 'json' }).value;
                    }
                    return escapeHtml(content);
                } catch (e) {
                    console.warn('Highlight error:', e);
                    return escapeHtml(content);
                }
            };

            // Tool Call (Arguments)
            const argsContent = formatJsonContent(call.arguments || (call.arguments === 0 ? 0 : null));
            const argsEl = document.getElementById('modalToolArgs');
            argsEl.innerHTML = highlightJson(argsContent);
            argsEl.classList.add('hljs', 'language-json');
            
            // Tool Call Response (Output)
            let outputContent;
            if (call.output !== undefined && call.output !== null) {
                outputContent = formatJsonContent(call.output);
            } else {
                outputContent = call.status === 'in_progress' ? 'Waiting for output...' : 'Tool did not return output.';
            }
            
            const outputEl = document.getElementById('modalToolOutput');
            outputEl.innerHTML = highlightJson(outputContent);
            outputEl.classList.add('hljs', 'language-json');
        }

        function openToolCallModal(callId) {
            const modal = document.getElementById('toolCallModal');
            const call = toolCalls.find((tc) => tc.callId === callId) || toolCalls[toolCalls.length - 1];
            if (!modal || !call) return;
            
            toolCallModalCallId = call.callId;
            renderToolCallModalContent(call);
            
            modal.classList.remove('hidden');
            modal.classList.add('flex');
        }

        function closeToolCallModal(silent = false) {
            const modal = document.getElementById('toolCallModal');
            if (!modal) return;
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            if (!silent) {
                toolCallModalCallId = null;
            }
        }

        function parseStreamEventData(raw) {
            if (!raw) return {};
            try {
                return JSON.parse(raw);
            } catch {
                return {};
            }
        }

        function ensureToolCall(callId, defaults = {}) {
            const id = callId || `tool-${Date.now()}`;
            let existing = toolCalls.find((tc) => tc.callId === id);
            const preferredTurnId = normalizeTurnId(defaults.turnId) || currentTurnId;

            if (!existing) {
                existing = {
                    callId: id,
                    toolName: defaults.toolName || 'Tool call',
                    arguments: defaults.arguments ?? null,
                    output: defaults.output ?? null,
                    status: defaults.status || 'in_progress',
                    type: defaults.type || 'tool',
                    startedAt: defaults.startedAt || Date.now(),
                    completedAt: defaults.completedAt ?? null,
                    turnId: resolveTurnId(preferredTurnId),
                    sequence: ++toolCallSequence,
                };
                toolCalls.push(existing);
            } else if (!existing.turnId) {
                existing.turnId = resolveTurnId(preferredTurnId);
            }

            return existing;
        }

        function applyToolCallUpdates(call, updates = {}) {
            Object.entries(updates).forEach(([key, value]) => {
                if (value !== undefined) {
                    call[key] = value;
                }
            });
        }

        function syncToolCallUI(call) {
            if (call) {
                updateToolCallStack(call.turnId);
            }
            if (toolCallModalCallId) {
                const active = toolCalls.find(tc => tc.callId === toolCallModalCallId);
                if (active) {
                    renderToolCallModalContent(active);
                } else {
                    toolCallModalCallId = null;
                    closeToolCallModal(true);
                }
            }
        }

        function mapToolStatus(status) {
            if (!status) return 'completed';
            if (status === 'failed' || status === 'error') return 'error';
            return 'completed';
        }

        function handleToolCallBeginEvent(data = {}) {
            const targetTurnId = normalizeTurnId(data.turnId) || currentTurnId;
            const call = ensureToolCall(data.callId, {
                toolName: data.toolName,
                arguments: data.arguments,
                status: 'in_progress',
                type: 'tool',
                startedAt: Date.now(),
                turnId: targetTurnId,
            });
            applyToolCallUpdates(call, {
                toolName: data.toolName,
                arguments: data.arguments,
                status: 'in_progress',
                type: 'tool',
            });
            syncToolCallUI(call);
        }

        function handleToolCallEndEvent(data = {}) {
            const targetTurnId = normalizeTurnId(data.turnId) || currentTurnId;
            const call = ensureToolCall(data.callId, { type: 'tool', turnId: targetTurnId });
            applyToolCallUpdates(call, {
                status: data.status ? mapToolStatus(data.status) : 'completed',
                output: data.output,
                completedAt: Date.now(),
            });
            syncToolCallUI(call);
        }

        function handleExecCommandBeginEvent(data = {}) {
            const targetTurnId = normalizeTurnId(data.turnId) || currentTurnId;
            const call = ensureToolCall(data.callId, {
                toolName: data.toolName || 'Command',
                arguments: data.arguments,
                status: 'in_progress',
                type: 'exec',
                startedAt: Date.now(),
                turnId: targetTurnId,
            });
            applyToolCallUpdates(call, {
                toolName: data.toolName || 'Command',
                arguments: data.arguments,
                type: 'exec',
                status: 'in_progress',
            });
            syncToolCallUI(call);
        }

        function handleExecCommandOutputDeltaEvent(data = {}) {
            if (!data.callId && !data.execId) return;
            const chunk = data.output ?? data.delta ?? data.text ?? '';
            const targetTurnId = normalizeTurnId(data.turnId) || currentTurnId;
            const call = ensureToolCall(data.callId || data.execId, {
                toolName: data.toolName || 'Command',
                type: 'exec',
                turnId: targetTurnId,
            });
            applyToolCallUpdates(call, {
                toolName: data.toolName || call.toolName,
                type: 'exec',
            });
            if (chunk) {
                if (call.output == null) {
                    call.output = chunk;
                } else if (typeof call.output === 'string' && typeof chunk === 'string') {
                    call.output += chunk;
                } else if (typeof chunk === 'string') {
                    call.output = `${formatToolCallJson(call.output)}\n${chunk}`;
                } else {
                    call.output = chunk;
                }
            }
            syncToolCallUI(call);
        }

        function handleExecCommandEndEvent(data = {}) {
            const targetTurnId = normalizeTurnId(data.turnId) || currentTurnId;
            const call = ensureToolCall(data.callId || data.execId, { type: 'exec', turnId: targetTurnId });
            applyToolCallUpdates(call, {
                status: data.status ? mapToolStatus(data.status) : 'completed',
                output: data.output ?? call.output,
                completedAt: Date.now(),
            });
            syncToolCallUI(call);
        }

        function handleTsExecBeginEvent(data = {}) {
            const targetTurnId = normalizeTurnId(data.turnId) || currentTurnId;
            const call = ensureToolCall(data.execId, {
                toolName: data.label || 'Code Execution',
                arguments: data.source,
                type: 'ts_exec',
                status: 'in_progress',
                startedAt: Date.now(),
                turnId: targetTurnId,
            });
            applyToolCallUpdates(call, {
                toolName: data.label || 'Code Execution',
                arguments: data.source,
                type: 'ts_exec',
                status: 'in_progress',
            });
            syncToolCallUI(call);
        }

        function handleTsExecEndEvent(data = {}) {
            const targetTurnId = normalizeTurnId(data.turnId) || currentTurnId;
            const call = ensureToolCall(data.execId, { type: 'ts_exec', turnId: targetTurnId });
            applyToolCallUpdates(call, {
                status: data.status ? mapToolStatus(data.status) : 'completed',
                output: data.output ?? call.output,
                completedAt: Date.now(),
            });
            syncToolCallUI(call);
        }

        async function initializeApp() {
            try {
                // Load existing conversations first
                const conversations = await loadConversations();
                
                if (conversations && conversations.length > 0) {
                    // Restore previous conversation if available
                    const savedId = localStorage.getItem('cody_conversation_id');
                    if (savedId && conversations.some(c => c.conversationId === savedId)) {
                        await switchConversation(savedId);
                        updateStatus('Connected', 'green');
                        console.log('Restored conversation:', savedId);
                        return;
                    }

                    // Otherwise switch to the most recent conversation
                    const mostRecent = conversations[0];
                    await switchConversation(mostRecent.conversationId);
                    updateStatus('Connected', 'green');
                    console.log('Switched to most recent conversation:', mostRecent.conversationId);
                    return;
                }
                
                // Create new conversation only if none exist
                await createNewConversation();
            } catch (error) {
                console.error('Failed to initialize:', error);
                updateStatus('Connection Failed', 'red');
                addSystemMessage('Failed to connect to Cody API. Check console for details.');
            }
        }

        async function loadConversations() {
            try {
                const response = await fetch(`${API_BASE}/conversations`);
                if (!response.ok) {
                    console.error('Failed to load conversations');
                    return [];
                }
                
                const data = await response.json();
                const conversations = data.conversations || [];
                
                const conversationsList = document.getElementById('conversationsList');
                if (!conversationsList) return conversations;
                
                // Clear existing list (except the "New Chat" button area)
                conversationsList.innerHTML = '';
                
                // Add each conversation
                conversations.slice(0, 20).forEach(conv => {
                    const convDiv = document.createElement('div');
                    const isActive = conv.conversationId === currentConversationId;
                    convDiv.className = `p-3 border-l-4 ${isActive ? 'border-orange-600 bg-orange-50' : 'border-transparent'} hover:border-tan-400 hover:bg-tan-100 cursor-pointer transition-colors`;
                    convDiv.onclick = () => switchConversation(conv.conversationId);
                    
                    let displayTitle = conv.title;
                    // If title is missing or generic, try to use the first message
                    if (!displayTitle || displayTitle === 'New Conversation') {
                        if (conv.firstMessage) {
                            displayTitle = conv.firstMessage;
                        } else {
                            displayTitle = conv.title || 'New Conversation';
                        }
                    }

                    const date = new Date(conv.updatedAt || conv.createdAt);
                    const timeAgo = getTimeAgo(date);
                    const msgCount = conv.messageCount !== undefined ? conv.messageCount : 0;
                    const previewText = conv.summary || conv.firstMessage || 'No messages yet';
                    
                    convDiv.innerHTML = `
                        <div class="flex items-start justify-between mb-0.5">
                            <h3 class="font-bold text-brown-900 text-sm truncate flex-1 mr-2" title="${escapeHtml(displayTitle)}">${escapeHtml(displayTitle)}</h3>
                            <span class="text-xs text-brown-500 whitespace-nowrap">${timeAgo}</span>
                        </div>
                        <p class="text-xs text-brown-600 truncate mb-2" title="${escapeHtml(previewText)}">${escapeHtml(previewText)}</p>
                        <div>
                            <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-tan-200 text-brown-800">
                                ${msgCount} messages
                            </span>
                        </div>
                    `;
                    
                    conversationsList.appendChild(convDiv);
                });
                
                return conversations;
            } catch (error) {
                console.error('Failed to load conversations:', error);
                return [];
            }
        }

        function switchConversation(conversationId) {
            if (conversationId === currentConversationId) return;
            
            // Close any existing SSE connection
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            
            currentConversationId = conversationId;
            localStorage.setItem('cody_conversation_id', conversationId);
            resetToolCallState({ flushHistory: true });
            
            // Clear chat history
            const chatHistory = document.getElementById('chatHistory');
            chatHistory.innerHTML = `
                <div class="flex items-center justify-center h-full text-tan-600">
                    <div class="text-center">
                        <p class="text-lg">Loading conversation...</p>
                    </div>
                </div>
            `;
            
            // Load conversation messages
            loadConversationMessages(conversationId);
            
            // Reload conversations list to highlight active one
            loadConversations();
        }

        async function loadConversationMessages(conversationId) {
            try {
                const response = await fetch(`${API_BASE}/conversations/${conversationId}`);
                if (!response.ok) {
                    throw new Error('Failed to load conversation');
                }
                
                const data = await response.json();
                const history = data.history || [];
                
                const chatHistory = document.getElementById('chatHistory');
                chatHistory.innerHTML = '';
                
                if (history.length === 0) {
                    chatHistory.innerHTML = `
                        <div class="flex items-center justify-center h-full text-tan-600">
                            <div class="text-center">
                                <p class="text-lg">Start a conversation</p>
                                <p class="text-sm mt-2">Type a message below to begin</p>
                            </div>
                        </div>
                    `;
                    return;
                }
                
                // Render messages
                history.forEach(msg => {
                    // Handle standard messages
                    if (msg.type === 'message' || (!msg.type && msg.role)) {
                        if (msg.role === 'user') {
                            addUserMessage(msg.content);
                        } else if (msg.role === 'assistant') {
                            addAgentMessage(msg.content);
                        }
                    } 
                    // Handle tool calls
                    else if (msg.type === 'tool_call') {
                        const isExec = msg.toolName === 'exec';
                        const call = ensureToolCall(msg.callId, {
                            toolName: msg.toolName,
                            arguments: msg.arguments,
                            status: msg.status || 'in_progress',
                            turnId: msg.turnId,
                            type: isExec ? 'exec' : 'tool'
                        });
                        applyToolCallUpdates(call, {
                            toolName: msg.toolName,
                            arguments: msg.arguments,
                            status: msg.status || 'in_progress',
                            turnId: msg.turnId
                        });
                        syncToolCallUI(call);
                    }
                    // Handle tool outputs
                    else if (msg.type === 'tool_output') {
                        const call = ensureToolCall(msg.callId, { turnId: msg.turnId });
                        applyToolCallUpdates(call, {
                            output: msg.output,
                            status: 'completed',
                            turnId: msg.turnId
                        });
                        syncToolCallUI(call);
                    }
                });
            } catch (error) {
                console.error('Failed to load conversation messages:', error);
                addSystemMessage('Failed to load conversation. Please try again.');
            }
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        async function createNewConversation() {
            try {
                // Close any existing SSE connection
                if (eventSource) {
                    eventSource.close();
                    eventSource = null;
                }
                
                // Create new conversation
                const response = await fetch(`${API_BASE}/conversations`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        modelProviderId: 'openai',
                        modelProviderApi: 'responses',
                        model: 'gpt-5-mini',
                        reasoningEffort: 'medium'
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Failed to create conversation: ${errorData.error?.message || 'Unknown error'}`);
                }

                const data = await response.json();
                currentConversationId = data.conversationId;
                resetToolCallState({ flushHistory: true });
                
                // Clear chat history
                const chatHistory = document.getElementById('chatHistory');
                chatHistory.innerHTML = `
                    <div class="flex items-center justify-center h-full text-tan-600">
                        <div class="text-center">
                            <p class="text-lg">Start a conversation</p>
                            <p class="text-sm mt-2">Type a message below to begin</p>
                        </div>
                    </div>
                `;
                
                // Reload conversations list
                await loadConversations();
                
                updateStatus('Connected', 'green');
                console.log('New conversation created:', currentConversationId);
            } catch (error) {
                console.error('Failed to create new conversation:', error);
                addSystemMessage('Failed to create new conversation. Please try again.');
            }
        }

        function setupEventListeners() {
            const textarea = document.getElementById('messageInput');
            
            // Auto-expand textarea
            textarea.addEventListener('input', (e) => {
                e.target.style.height = 'auto';
                const newHeight = Math.min(e.target.scrollHeight, 168);
                e.target.style.height = newHeight + 'px';
                
                // Update character count
                const charCount = e.target.value.length;
                document.getElementById('charCount').textContent = `${charCount} / 4000`;
            });

            // Handle Enter key
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeToolCallModal();
                }
            });
        }

        async function sendMessage() {
            const textarea = document.getElementById('messageInput');
            const message = textarea.value.trim();
            
            if (!message || !currentConversationId) return;

            // Clear input and reset height
            textarea.value = '';
            textarea.style.height = 'auto';
            document.getElementById('charCount').textContent = '0 / 4000';

            // Add user message to UI
            addUserMessage(message);

            // Disable send button
            const sendButton = document.getElementById('sendButton');
            sendButton.disabled = true;

            try {
                // Send message to API
                const response = await fetch(`${API_BASE}/conversations/${currentConversationId}/messages`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ message })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Send message failed:', response.status, response.statusText, errorText);
                    throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                currentTurnId = data.turnId;
                resetToolCallState();

                // Start streaming
                streamTurn(data.turnId);

            } catch (error) {
                console.error('Failed to send message:', error);
                addSystemMessage('Failed to send message. Please try again.');
                sendButton.disabled = false;
            }
        }

        function streamTurn(turnId) {
            // Close existing connection if any
            if (eventSource) {
                eventSource.close();
            }

            const streamUrl = `${API_BASE}/turns/${turnId}/stream-events?thinkingLevel=full&toolLevel=full&toolFormat=full`;
            console.log('Connecting to SSE stream:', streamUrl);
            eventSource = new EventSource(streamUrl);

            let currentAgentMessageId = null;
            let agentMessageText = '';

            eventSource.addEventListener('task_started', (e) => {
                console.log('Task started:', e.data);
                updateStatus('Processing...', 'yellow');
            });

            eventSource.addEventListener('agent_message', (e) => {
                console.log('Agent message event received:', e.data);
                try {
                const data = JSON.parse(e.data);
                    console.log('Parsed agent message data:', data);
                
                if (!currentAgentMessageId) {
                    currentAgentMessageId = addAgentMessage('');
                    agentMessageText = '';
                }
                
                    const messageText = data.message || data.text || '';
                    console.log('Adding message text:', messageText);
                    agentMessageText += messageText;
                updateAgentMessage(currentAgentMessageId, agentMessageText);
                } catch (error) {
                    console.error('Error parsing agent_message:', error, e.data);
                }
            });

            eventSource.addEventListener('agent_reasoning', (e) => {
                try {
                    const data = JSON.parse(e.data);
                    const text = data.text || data.message || data.content || '';
                    if (text) {
                        addReasoningMessage(text);
                    }
                } catch (error) {
                    console.error('Error parsing agent_reasoning:', error);
                }
            });

            eventSource.addEventListener('tool_call_begin', (e) => {
                handleToolCallBeginEvent(parseStreamEventData(e.data));
            });

            eventSource.addEventListener('tool_call_end', (e) => {
                handleToolCallEndEvent(parseStreamEventData(e.data));
            });

            eventSource.addEventListener('exec_command_begin', (e) => {
                handleExecCommandBeginEvent(parseStreamEventData(e.data));
            });

            eventSource.addEventListener('exec_command_output_delta', (e) => {
                handleExecCommandOutputDeltaEvent(parseStreamEventData(e.data));
            });

            eventSource.addEventListener('exec_command_end', (e) => {
                handleExecCommandEndEvent(parseStreamEventData(e.data));
            });

            eventSource.addEventListener('ts_exec_begin', (e) => {
                handleTsExecBeginEvent(parseStreamEventData(e.data));
            });

            eventSource.addEventListener('ts_exec_end', (e) => {
                handleTsExecEndEvent(parseStreamEventData(e.data));
            });

            eventSource.addEventListener('task_complete', (e) => {
                console.log('Task complete:', e.data);
                updateStatus('Connected', 'green');
                document.getElementById('sendButton').disabled = false;
                
                if (currentAgentMessageId) {
                    finalizeAgentMessage(currentAgentMessageId);
                }
                
                // Reload conversations to update the list
                loadConversations();
                
                eventSource.close();
                eventSource = null;
            });

            eventSource.addEventListener('turn_aborted', (e) => {
                const data = JSON.parse(e.data);
                console.log('Turn aborted:', data);
                addSystemMessage('Turn was aborted: ' + (data.reason || 'Unknown reason'));
                updateStatus('Connected', 'green');
                document.getElementById('sendButton').disabled = false;
                eventSource.close();
                eventSource = null;
            });

            eventSource.addEventListener('error', (e) => {
                console.error('Stream error:', e);
                updateStatus('Error', 'red');
                document.getElementById('sendButton').disabled = false;
                
                if (eventSource) {
                    eventSource.close();
                    eventSource = null;
                }
            });

            eventSource.onerror = (e) => {
                console.error('EventSource error:', e);
                console.error('EventSource readyState:', eventSource?.readyState);
                console.error('EventSource url:', eventSource?.url);
                
                // Check if connection was closed by server (readyState 2)
                if (eventSource?.readyState === EventSource.CLOSED) {
                    console.log('SSE connection closed by server');
                    updateStatus('Connected', 'green');
                } else {
                updateStatus('Connection Error', 'red');
                }
                
                document.getElementById('sendButton').disabled = false;
                
                if (eventSource) {
                    eventSource.close();
                    eventSource = null;
                }
            };
            
            // Log when connection opens
            eventSource.onopen = () => {
                console.log('SSE connection opened');
            };
        }

        function addUserMessage(text) {
            const chatHistory = document.getElementById('chatHistory');
            
            // Clear empty state if present (check for the specific empty state message)
            const emptyState = chatHistory.querySelector('.flex.items-center.justify-center');
            if (emptyState && emptyState.textContent.includes('Start a conversation')) {
                emptyState.remove();
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'flex justify-end';
            messageDiv.innerHTML = `
                <div class="max-w-3xl">
                    <div class="bg-orange-600 text-white rounded-lg px-4 py-3 shadow">
                        <div class="message-content">${escapeHtml(text)}</div>
                    </div>
                </div>
            `;
            
            chatHistory.appendChild(messageDiv);
            scrollToBottom();
            
            // Add to thread navigator
            addToThreadNav('user', text);
            
            messageHistory.push({ role: 'user', content: text, element: messageDiv });
        }

        function addAgentMessage(text) {
            const chatHistory = document.getElementById('chatHistory');
            
            // Clear empty state if present (check for the specific empty state message)
            const emptyState = chatHistory.querySelector('.flex.items-center.justify-center');
            if (emptyState && emptyState.textContent.includes('Start a conversation')) {
                emptyState.remove();
            }
            
            const messageId = 'agent-' + Date.now();
            
            const messageDiv = document.createElement('div');
            messageDiv.id = messageId;
            messageDiv.className = 'flex justify-start';
            messageDiv.innerHTML = `
                <div class="max-w-3xl">
                    <div class="bg-white border-2 border-tan-300 rounded-lg px-4 py-3 shadow">
                        <div class="flex items-center mb-2">
                            <div class="w-6 h-6 bg-orange-600 rounded flex items-center justify-center text-white text-xs font-bold mr-2">C</div>
                            <span class="text-sm font-semibold text-brown-800">Cody</span>
                        </div>
                        <div class="message-content text-brown-900">${escapeHtml(text)}</div>
                    </div>
                </div>
            `;
            
            chatHistory.appendChild(messageDiv);
            scrollToBottom();
            
            messageHistory.push({ role: 'assistant', content: text, element: messageDiv, id: messageId });
            return messageId;
        }

        function updateAgentMessage(messageId, text) {
            const messageDiv = document.getElementById(messageId);
            if (!messageDiv) {
                console.error('Message div not found for ID:', messageId);
                return;
            }
                const contentDiv = messageDiv.querySelector('.message-content');
            if (!contentDiv) {
                console.error('Content div not found in message:', messageId);
                return;
            }
                contentDiv.textContent = text;
                scrollToBottom();
        }

        function finalizeAgentMessage(messageId) {
            const messageDiv = document.getElementById(messageId);
            if (messageDiv) {
                const text = messageDiv.querySelector('.message-content').textContent;
                addToThreadNav('assistant', text);
            }
        }

        function addReasoningMessage(text) {
            const chatHistory = document.getElementById('chatHistory');
            
            // Check if the last message was a reasoning message to append to it
            const lastMessage = chatHistory.lastElementChild;
            if (lastMessage && lastMessage.classList.contains('reasoning-message')) {
                const contentDiv = lastMessage.querySelector('.reasoning-content');
                if (contentDiv) {
                    contentDiv.textContent += text;
                    scrollToBottom();
                    return;
                }
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'flex justify-start reasoning-message';
            messageDiv.innerHTML = `
                <div class="max-w-3xl w-full">
                    <div class="bg-tan-200 border-l-4 border-tan-400 rounded-r-lg px-4 py-3 shadow-sm my-2">
                        <div class="flex items-center mb-1">
                            <svg class="w-4 h-4 mr-2 text-tan-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                            </svg>
                            <span class="text-xs font-bold uppercase tracking-wide text-tan-700">Reasoning</span>
                        </div>
                        <div class="reasoning-content text-sm text-brown-800 font-mono whitespace-pre-wrap">${escapeHtml(text)}</div>
                    </div>
                </div>
            `;
            
            chatHistory.appendChild(messageDiv);
            scrollToBottom();
        }

        function addSystemMessage(text) {
            const chatHistory = document.getElementById('chatHistory');
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'flex justify-center';
            messageDiv.innerHTML = `
                <div class="max-w-2xl">
                    <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded-lg text-sm">
                        ${escapeHtml(text)}
                    </div>
                </div>
            `;
            
            chatHistory.appendChild(messageDiv);
            scrollToBottom();
        }

        function addToThreadNav(role, content) {
            const threadNav = document.getElementById('threadNav');
            if (!threadNav) return; // Thread nav doesn't exist, skip
            
            // Remove empty state
            if (threadNav.querySelector('.text-center')) {
                threadNav.innerHTML = '';
            }
            
            const preview = content.substring(0, 50) + (content.length > 50 ? '...' : '');
            const icon = role === 'user' ? '👤' : '🤖';
            const bgColor = role === 'user' ? 'bg-orange-100 hover:bg-orange-200' : 'bg-tan-200 hover:bg-tan-300';
            
            const navItem = document.createElement('div');
            navItem.className = `nav-item ${bgColor} rounded-lg p-2 mb-2 cursor-pointer transition-colors`;
            navItem.innerHTML = `
                <div class="flex items-start">
                    <span class="mr-2 text-sm">${icon}</span>
                    <div class="flex-1 min-w-0">
                        <div class="text-xs text-brown-600 font-medium mb-1">${role === 'user' ? 'You' : 'Cody'}</div>
                        <div class="text-xs text-brown-700 truncate">${escapeHtml(preview)}</div>
                    </div>
                </div>
            `;
            
            // Scroll to message on click
            navItem.onclick = () => {
                const messageElements = messageHistory.filter(m => m.role === role && m.content.startsWith(content.substring(0, 30)));
                if (messageElements.length > 0) {
                    messageElements[messageElements.length - 1].element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            };
            
            threadNav.appendChild(navItem);
        }

        function updateStatus(text, color) {
            const statusIndicator = document.getElementById('statusIndicator');
            const colors = {
                'green': 'bg-green-500',
                'yellow': 'bg-yellow-500',
                'red': 'bg-red-500'
            };
            
            statusIndicator.innerHTML = `
                <span class="inline-block w-2 h-2 ${colors[color]} rounded-full mr-1"></span>
                ${text}
            `;
        }

        function toggleLeftSidebar() {
            const sidebar = document.getElementById('leftSidebar');
            const toggle = document.getElementById('leftSidebarToggle');
            
            if (sidebar.classList.contains('-ml-64')) {
                sidebar.classList.remove('-ml-64');
                toggle.classList.add('hidden');
            } else {
                sidebar.classList.add('-ml-64');
                toggle.classList.remove('hidden');
            }
        }

        function toggleRightSidebar() {
            const sidebar = document.getElementById('rightSidebar');
            const toggle = document.getElementById('rightSidebarToggle');
            
            if (sidebar.classList.contains('-mr-64')) {
                sidebar.classList.remove('-mr-64');
                toggle.classList.add('hidden');
            } else {
                sidebar.classList.add('-mr-64');
                toggle.classList.remove('hidden');
            }
        }

        function scrollToMessage(messageId) {
            const element = document.querySelector(`[data-message-id="${messageId}"]`);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Flash highlight
                element.classList.add('ring-2', 'ring-orange-500', 'ring-opacity-50');
                setTimeout(() => {
                    element.classList.remove('ring-2', 'ring-orange-500', 'ring-opacity-50');
                }, 1000);
            }
        }

        function scrollToBottom() {
            const chatHistory = document.getElementById('chatHistory');
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>
